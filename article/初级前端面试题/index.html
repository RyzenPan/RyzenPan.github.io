<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          前端必须知道的面试题 - RyzenPan | Blog
        
    </title>

    <link rel="canonical" href="https://ryzenpan.github.io/article/初级前端面试题/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/article_header/article_bg.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#interview" title="interview">interview</a>
                            
                        </div>
                        <h1>前端必须知道的面试题</h1>
                        <h2 class="subheading">助你金三银四，一路过关砍将</h2>
                        <span class="meta">
                            Posted by RyzenPan on
                            2020-01-03
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">RyzenPan</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="前端入坑必须知道的面试题">前端入坑必须知道的面试题</h1>
<h2 id="前言">前言</h2>
<p>进入到前端web开发这个行业已经有点时间了，抽空整理了一下一些面试经常问到问题，虽然都是比较基础的，但是对于想要精通前端技术的同学来说应该是有用的！</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d59aaa6aa62269?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"></p>
<h2 id="html">HTML</h2>
<h3 id="html语义化">HTML语义化</h3>
<p>HTML语义化就是让页面内容结构化，它有如下优点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</span><br><span class="line">2、有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</span><br><span class="line">3、方便其他设备解析，如盲人阅读器根据语义渲染网页</span><br><span class="line">4、有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;代表头部</span><br><span class="line">&lt;nav&gt;代表超链接区域</span><br><span class="line">&lt;main&gt;定义文档主要内容</span><br><span class="line">&lt;article&gt;可以表示文章、博客等内容</span><br><span class="line">&lt;aside&gt;通常表示侧边栏或嵌入内容</span><br><span class="line">&lt;footer&gt;代表尾部</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="html5新标签">HTML5新标签</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有&lt;header&gt;、&lt;footer&gt;、&lt;aside&gt;、&lt;nav&gt;、&lt;video&gt;、&lt;audio&gt;、&lt;canvas&gt;等...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="css">CSS</h2>
<h3 id="盒子模型">盒子模型</h3>
<p>盒模型分为标准盒模型和怪异盒模型(IE模型)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box-sizing：content-box   //标准盒模型</span><br><span class="line">box-sizing：border-box    //怪异盒模型</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/9/16d1528aff0ef536?imageslim" alt="cmd-markdown-logo"></p>
<p>标准盒模型：元素的宽度等于style里的width+margin+border+padding宽度</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/9/16d158cb1351e5b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"></p>
<blockquote>
<p>如下代码，整个宽高还是120px</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    box-sizing: content-box;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>怪异盒模型：元素宽度等于style里的width宽度</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/9/16d158e2ebd5fefe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cmd-markdown-logo"></p>
<blockquote>
<p>如下代码，整个宽高还是100px</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>注意：如果你在设计页面中，发现内容区被撑爆了，那么就先检查一下border-sizing是什么，最好在引用reset.css的时候，就对border-sizing进行统一设置，方便管理</p>
<h3 id="rem与em的区别">rem与em的区别</h3>
<blockquote>
<p>rem是根据根的font-size变化，而em是根据父级的font-size变化</p>
</blockquote>
<p>rem：相对于根元素html的font-size，假如html为font-size：12px，那么，在其当中的div设置为font-size：2rem,就是当中的div为24px</p>
<p>em：相对于父元素计算，假如某个p元素为font-size:12px,在它内部有个span标签，设置font-size：2em,那么，这时候的span字体大小为：12*2=24px</p>
<h3 id="css选择器">CSS选择器</h3>
<p><strong>css常用选择器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通配符：*</span><br><span class="line">ID选择器：#ID</span><br><span class="line">类选择器：.class</span><br><span class="line">元素选择器：p、a    等</span><br><span class="line">后代选择器：p span、div a   等</span><br><span class="line">伪类选择器：a:hover 等</span><br><span class="line">属性选择器：input[type=&quot;text&quot;]  等</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>css选择器权重</strong></p>
<p>!important -&gt; 行内样式 -&gt; #id -&gt; .class -&gt; 元素和伪元素 -&gt; * -&gt; 继承 -&gt; 默认</p>
<h3 id="css新特性">CSS新特性</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">transition：过渡</span><br><span class="line">transform：旋转、缩放、移动或者倾斜</span><br><span class="line">animation：动画</span><br><span class="line">gradient：渐变</span><br><span class="line">shadow：阴影</span><br><span class="line">border-radius：圆角</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="行内元素和块级元素">行内元素和块级元素</h3>
<p><strong>行内元素（display: inline）</strong></p>
<p>宽度和高度是由内容决定，与其他元素共占一行的元素，我们将其叫行内元素，例如：<code>、 、</code>等</p>
<p><strong>块级元素（display: block)</strong></p>
<p>默认宽度由父容器决定，默认高度由内容决定，独占一行并且可以设置宽高的元素，我们将其叫做块级元素，例如：<code>、 、等</code></p>
<p>在平时，我们经常使用CSS的display: inline-block，使它们拥有更多的状态</p>
<h3 id="绝对定位和相对定位的区别">绝对定位和相对定位的区别</h3>
<p><strong>position: absolute</strong><br>
绝对定位：是相对于元素最近的已定位的祖先元素</p>
<p><strong>position: relative</strong><br>
相对定位：相对定位是相对于元素在文档中的初始位置</p>
<h3 id="flex布局">Flex布局</h3>
<p><a href="https://juejin.im/post/5d428c5451882556dc30535c" target="_blank" rel="noopener">juejin.im/post/5d428c…</a></p>
<h3 id="bfc">BFC</h3>
<p><strong>什么是BFC?</strong></p>
<p>BFC格式化上下文，它是一个独立的渲染区域，让处于 BFC 内部的元素和外部的元素相互隔离，使内外元素的定位不会相互影响</p>
<p><strong>如何产生BFC?</strong></p>
<p>display: inline-block</p>
<p>position: absolute/fixed</p>
<p><strong>BFC作用</strong></p>
<p>BFC最大的一个作用就是：在页面上有一个独立隔离容器，容器内的元素和容器外的元素布局不会相互影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决上外边距重叠;重叠的两个box都开启bfc;</span><br><span class="line">解决浮动引起高度塌陷;容器盒子开启bfc</span><br><span class="line">解决文字环绕图片;左边图片div,右边文字容器p,将p容器开启bfc</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="水平垂直居中">水平垂直居中</h3>
<p><strong>Flex布局</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">display: flex  //设置Flex模式</span><br><span class="line">flex-direction: column  //决定元素是横排还是竖着排</span><br><span class="line">flex-wrap: wrap     //决定元素换行格式</span><br><span class="line">justify-content: space-between  //同一排下对齐方式，空格如何隔开各个元素</span><br><span class="line">align-items: center     //同一排下元素如何对齐</span><br><span class="line">align-content: space-between    //多行对齐方式</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>水平居中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">行内元素：display: inline-block;</span><br><span class="line">块级元素：margin: 0 auto;</span><br><span class="line">Flex: display: flex; justify-content: center</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>垂直居中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行高 = 元素高：line-height: height</span><br><span class="line">flex: display: flex; align-item: center</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="lesssassstyus三者的区别">less,sass,styus三者的区别</h3>
<p><strong>变量</strong></p>
<p>Sass声明变量必须是『$』开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号：分隔开。Less 声明变量用『@』开头，其余等同 Sass。</p>
<p>Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。</p>
<p><strong>作用域</strong></p>
<p>Sass：三者最差，不存在全局变量的概念Less：最近的一次更新的变量有效，并且会作用于全部的引用！</p>
<p>Stylus：Sass 的处理方式和 Stylus 相同，变量值输出时根据之前最近的一次定义计算，每次引用最近的定义有效；</p>
<p><strong>嵌套</strong></p>
<p>三种 css 预编译器的「选择器嵌套」在使用上来说没有任何区别，甚至连引用父级选择器的标记 &amp; 也相同</p>
<p><strong>继承</strong></p>
<p>Sass和Stylus的继承非常像，能把一个选择器的所有样式继承到另一个选择器上。使用『@extend』开始，后面接被继承的选择器。Stylus 的继承方式来自 Sass，两者如出一辙。 Less 则又「独树一帜」地用伪类来描述继承关系；</p>
<p><strong>导入@Import</strong></p>
<p>Sass 中只能在使用 url() 表达式引入时进行变量插值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$device: mobile;</span><br><span class="line">@import url(styles.#&#123;$device&#125;.css);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>Less 中可以在字符串中进行插值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@device: mobile;</span><br><span class="line">@import &quot;styles.@&#123;device&#125;.css&quot;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>Stylus 中在这里插值不管用，但是可以利用其字符串拼接的功能实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">device = &quot;mobile&quot;</span><br><span class="line">@import &quot;styles.&quot; + device + &quot;.css&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>Sass和Less语法严谨、Stylus相对自由。因为Less长得更像 css，所以它可能学习起来更容易。Sass 和 Compass、Stylus 和 Nib 都是好基友。Sass 和 Stylus 都具有类语言的逻辑方式处理：条件、循环等，而 Less 需要通过When等关键词模拟这些功能，这方面 Less 比不上 Sass 和 Stylus</p>
<p>Less 在丰富性以及特色上都不及 Sass 和 Stylus，若不是因为 Bootstrap 引入了 Less，可能它不会像现在这样被广泛应用（个人愚见）</p>
<h3 id="link与import区别与选择">link与@import区别与选择</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	@import url(CSS文件路径地址);</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;link href=&quot;CSSurl路径&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css；当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载；@import需要 IE5 以上才能使用；</p>
<p>link可以使用 js 动态引入，@import不行</p>
<h3 id="多行元素的文本省略号">多行元素的文本省略号</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">overflow : hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-line-clamp: 3;</span><br><span class="line">-webkit-box-orient: vertical</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="javascript">JavaScript</h2>
<h3 id="js的几条基本规范">JS的几条基本规范</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、不要在同一行声明多个变量</span><br><span class="line">2、请使用===/！==来比较true/false或者数值</span><br><span class="line">3、使用对象字面量替代new Array这种形式</span><br><span class="line">4、不要使用全局变量</span><br><span class="line">5、Switch语句必须带有default分支</span><br><span class="line">6、函数不应该有时候有返回值，有时候没有返回值</span><br><span class="line">7、For循环必须使用大括号</span><br><span class="line">8、IF语句必须使用大括号</span><br><span class="line">9、for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="js引用方法">JS引用方法</h3>
<p><strong>行内引入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot; onclick=&quot;alert(&apos;行内引入&apos;)&quot; value=&quot;按钮&quot;/&gt;</span><br><span class="line">  &lt;button onclick=&quot;alert(123)&quot;&gt;点击我&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>内部引入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload = function() &#123;</span><br><span class="line">    alert(&quot;js 内部引入！&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>外部引入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;./js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1，不推荐写行内或者HTML中插入&lt;script&gt;,因为浏览器解析顺序缘故，如果解析到死循环之类的JS代码，会卡住页面</span><br><span class="line">2，建议在onload事件之后，即等HTML、CSS渲染完毕再执行代码</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="js的基本数据类型">JS的基本数据类型</h3>
<p>Undefined、Null、Boolean、Number、String、新增:Symbol</p>
<h3 id="数组操作">数组操作</h3>
<blockquote>
<p>在 JavaScript 中，用得较多的之一无疑是数组操作，这里过一遍数组的一些用法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map: 遍历数组，返回回调返回值组成的新数组</span><br><span class="line">forEach: 无法break，可以用try/catch中throw new Error来停止</span><br><span class="line">filter: 过滤</span><br><span class="line">some: 有一项返回true，则整体为true</span><br><span class="line">every: 有一项返回false，则整体为false</span><br><span class="line">join: 通过指定连接符生成字符串</span><br><span class="line">push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项【有误】</span><br><span class="line">unshift / shift: 头部推入和弹出，改变原数组，返回操作项【有误】</span><br><span class="line">sort(fn) / reverse: 排序与反转，改变原数组</span><br><span class="line">concat: 连接数组，不影响原数组， 浅拷贝</span><br><span class="line">slice(start, end): 返回截断后的新数组，不改变原数组</span><br><span class="line">splice(start, number, value...): 返回删除元素组成的数组，value 为插入项，改变原数组</span><br><span class="line">indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标</span><br><span class="line">reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur 为当前值(从第二项开始)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="js有哪些内置对象">JS有哪些内置对象</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object是JavaScript中所有对象的父对象</span><br><span class="line"></span><br><span class="line">数据封装对象：Object、Array、Boolean、Number和String</span><br><span class="line">其他对象：Function、Arguments、Math、Date、RegExp、Error</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="get请求传参长度的误区">get请求传参长度的误区</h3>
<p>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的</p>
<p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p>
<p>1、HTTP 协议 未规定 GET 和POST的长度限制</p>
<p>2、GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</p>
<p>3、不同的浏览器和WEB服务器，限制的最大长度不一样</p>
<p>4、要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</p>
<h3 id="补充get和post请求在缓存方面的区别">补充get和post请求在缓存方面的区别</h3>
<ul>
<li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li>
<li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>
</ul>
<h3 id="闭包">闭包</h3>
<p><strong>什么是闭包？</strong></p>
<p>函数A 里面包含了 函数B，而 函数B 里面使用了 函数A 的变量，那么 函数B 被称为闭包。</p>
<p>又或者：闭包就是能够读取其他函数内部变量的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  function B() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  return B();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>闭包的特征</strong></p>
<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收制回收</li>
</ul>
<p><strong>对闭包的理解</strong></p>
<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
<p>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法</p>
<p><strong>闭包的好处</strong></p>
<p>能够实现封装和缓存等</p>
<p><strong>闭包的坏处</strong></p>
<p>就是消耗内存、不正当使用会造成内存溢出的问题</p>
<p><strong>使用闭包的注意点</strong></p>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</p>
<p>解决方法是：在退出函数之前，将不使用的局部变量全部删除</p>
<p><strong>闭包的经典问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这段代码输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：3个3</span><br><span class="line">解析：首先，for 循环是同步代码，先执行三遍 for，i 变成了 3；然后，再执行异步代码 setTimeout，这时候输出的 i，只能是 3 个 3 了</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>有什么办法依次输出0 1 2</p>
<blockquote>
<p>第一种方法</p>
</blockquote>
<p>使用let</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在这里，每个 let 和代码块结合起来形成块级作用域，当 setTimeout() 打印时，会寻找最近的块级作用域中的 i，所以依次打印出 0 1 2</p>
<p>如果这样不明白，我们可以执行下边这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  console.log(&quot;定时器外部：&quot; + i);</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>此时浏览器依次输出的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定时器外部：0</span><br><span class="line">定时器外部：1</span><br><span class="line">定时器外部：2</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>即代码还是先执行 for 循环，但是当 for 结束执行到了 setTimeout 的时候，它会做个标记，这样到了 console.log(i) 中，i 就能找到这个块中最近的变量定义</p>
<blockquote>
<p>第二种方法</p>
</blockquote>
<p>使用立即执行函数解决闭包的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  (function(i)&#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="js作用域及作用域链">JS作用域及作用域链</h3>
<p><strong>作用域</strong></p>
<p>在JavaScript中，作用域分为 全局作用域 和 函数作用域</p>
<blockquote>
<p>全局作用域</p>
</blockquote>
<p>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域</p>
<blockquote>
<p>函数作用域</p>
</blockquote>
<p>在固定的代码片段才能被访问</p>
<p>例子：</p>
<p>![cmd-markdown-logo](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="445" height="227">)</svg></p>
<p>作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。</p>
<p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p>
<p>变量取值：到创建 这个变量 的函数的作用域中取值</p>
<p><strong>作用域链</strong></p>
<p>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</p>
<p>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p>
<p>![cmd-markdown-logo](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="465" height="307">)</svg></p>
<h3 id="原型和原型链">原型和原型链</h3>
<p><strong>原型和原型链的概念</strong></p>
<p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去</p>
<p><strong>原型和原型链的关系</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance.constructor.prototype = instance.__proto__</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>原型和原型链的特点</strong></p>
<p>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</p>
<p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的</p>
<p>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</p>
<h3 id="组件化和模块化">组件化和模块化</h3>
<p><strong>组件化</strong></p>
<p><strong>为什么要组件化开发</strong></p>
<p>有时候页面代码量太大，逻辑太多或者同一个功能组件在许多页面均有使用，维护起来相当复杂，这个时候，就需要组件化开发来进行功能拆分、组件封装，已达到组件通用性，增强代码可读性，维护成本也能大大降低</p>
<p><strong>组件化开发的优点</strong></p>
<p>很大程度上降低系统各个功能的耦合性，并且提高了功能内部的聚合性。这对前端工程化及降低代码的维护来说，是有很大的好处的，耦合性的降低，提高了系统的伸展性，降低了开发的复杂度，提升开发效率，降低开发成本</p>
<p><strong>组件化开发的原则</strong></p>
<ul>
<li>专一</li>
<li>可配置性</li>
<li>标准性</li>
<li>复用性</li>
<li>可维护性</li>
</ul>
<p><strong>模块化</strong></p>
<p><strong>为什么要模块化</strong></p>
<p>早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切</p>
<p><strong>模块化的好处</strong></p>
<ul>
<li>避免变量污染，命名冲突</li>
<li>提高代码复用率</li>
<li>提高了可维护性</li>
<li>方便依赖关系管理</li>
</ul>
<p><strong>模块化的几种方法</strong></p>
<ul>
<li>函数封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var myModule = &#123;</span><br><span class="line">    var1: 1,</span><br><span class="line">    </span><br><span class="line">    var2: 2,</span><br><span class="line">    </span><br><span class="line">    fn1: function()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    fn2: function()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">总结：这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系</span><br><span class="line"></span><br><span class="line">缺陷：外部可以睡意修改内部成员，这样就会产生意外的安全问题</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>立即执行函数表达式(IIFE)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var myModule = (function()&#123;</span><br><span class="line">    var var1 = 1;</span><br><span class="line">    var var2 = 2;</span><br><span class="line">    </span><br><span class="line">    function fn1()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    function fn2()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">    fn1: fn1,</span><br><span class="line">    fn2: fn2</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">复制代码</span><br><span class="line">总结：这样在模块外部无法修改我们没有暴露出来的变量、函数</span><br><span class="line"></span><br><span class="line">缺点：功能相对较弱，封装过程增加了工作量，仍会导致命名空间污染可能、闭包是有成本的</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="图片的预加载和懒加载">图片的预加载和懒加载</h3>
<ul>
<li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染</li>
<li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数</li>
</ul>
<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。</p>
<h3 id="mouseover和mouseenter的区别">mouseover和mouseenter的区别</h3>
<p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</p>
<p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</p>
<h3 id="解决异步回调地狱">解决异步回调地狱</h3>
<p>promise、generator、async/await</p>
<h3 id="对this对象的理解">对This对象的理解</h3>
<p>this总是指向函数的直接调用者（而非间接调用者）如果有new关键字，this指向new出来的那个对象</p>
<p>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</p>
<h2 id="vue">Vue</h2>
<h3 id="vue生命周期">vue生命周期</h3>
<p><strong>什么是Vue生命周期？</strong></p>
<p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期</p>
<p><strong>Vue生命周期的作用是什么？</strong></p>
<p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑</p>
<p><strong>Vue生命周期总共有几个阶段？</strong></p>
<p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>
<p><strong>第一次页面加载会触发哪几个钩子？</strong></p>
<p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p>
<p><strong>DOM渲染在哪个周期中就已经完成？</strong></p>
<p>DOM 渲染在 mounted 中就已经完成了</p>
<p><strong>每个生命周期适合哪些场景？</strong></p>
<p>生命周期钩子的一些使用方法：</p>
<p>beforecreate : 可以在这加个loading事件，在加载实例时触发created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用mounted : 挂载元素，获取到DOM节点updated : 如果对数据统一处理，在这里写上相应函数beforeDestroy : 可以做一个确认停止事件的确认框</p>
<p>nextTick : 更新数据后立即操作dom</p>
<h3 id="v-show与v-if区别">v-show与v-if区别</h3>
<p>v-show是css切换，v-if是完整的销毁和重新创建使用 频繁切换时用v-show，运行时较少改变时用v-if</p>
<p>v-if=‘false’ v-if是条件渲染，当false的时候不会渲染</p>
<h3 id="开发中常用的指令有哪些">开发中常用的指令有哪些</h3>
<p>v-model :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定v-html: 更新元素的 innerHTML</p>
<p>v-show 与 v-if: 条件渲染, 注意二者区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成</span><br><span class="line">v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>v-on : click: 可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数 v-for:基于源数据多次渲染元素或模板块 v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：v-bind:title=&quot;msg&quot; 简写：:title=&quot;msg&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="绑定class的数组用法">绑定class的数组用法</h3>
<p>对象方法 v-bind:class=&quot;{‘orange’: isRipe, ‘green’: isNotRipe}“数组方法 v-bind:class=”[class1, class2]&quot;</p>
<p>行内 v-bind:style=&quot;{color: color, fontSize: fontSize+‘px’ }&quot;</p>
<h3 id="组件之间的传值通信">组件之间的传值通信</h3>
<p><strong>父组件给子组件传值</strong></p>
<blockquote>
<p>使用props，父组件可以使用props向子组件传递数据</p>
</blockquote>
<p>父组件vue模板father.vue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &apos;./child.vue&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &apos;father message&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>子组件vue模板child.vue:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        msg: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            required: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>子组件向父组件通信</strong></p>
<blockquote>
<p>父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件</p>
</blockquote>
<p>父组件vue模板father.vue:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child @msgFunc=&quot;func&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &apos;./child.vue&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        func (msg) &#123;</span><br><span class="line">            console.log(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>子组件vue模板child.vue:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        msg: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            required: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods () &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            //........</span><br><span class="line">            this.$emit(&apos;msgFunc&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>非父子，兄弟组件之间通信</strong></p>
<blockquote>
<p>可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递</p>
</blockquote>
<p>Bus.js可以是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">export default new Vue()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在需要通信的组件都引入Bus.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;button @click=&quot;toBus&quot;&gt;子组件传给兄弟组件&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &apos;../common/js/bus.js&apos;</span><br><span class="line">export default&#123;</span><br><span class="line">	methods: &#123;</span><br><span class="line">	    toBus () &#123;</span><br><span class="line">	        Bus.$emit(&apos;on&apos;, &apos;来自兄弟组件&apos;)</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>另一个组件也import Bus.js 在钩子函数中监听on事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Bus from &apos;../common/js/bus.js&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">       Bus.$on(&apos;on&apos;, (msg) =&gt; &#123;</span><br><span class="line">         this.message = msg</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="路由跳转方式">路由跳转方式</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，&lt;router-link to=&apos;home&apos;&gt; router-link标签会渲染为&lt;a&gt;标签，咋填template中的跳转都是这种；</span><br><span class="line"></span><br><span class="line">2，另一种是编程是导航 也就是通过js跳转 比如 router.push(&apos;/home&apos;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="mvvm">MVVM</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</span><br><span class="line"></span><br><span class="line">V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</span><br><span class="line"></span><br><span class="line">VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="computed和watch有什么区别">computed和watch有什么区别?</h3>
<p><strong>computed:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. computed是计算属性,也就是计算值,它更多用于计算值的场景</span><br><span class="line">2. computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</span><br><span class="line">3. computed适用于计算比较消耗性能的计算场景</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>watch:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</span><br><span class="line">2. 无缓存性，页面重新渲染时值不变化也会执行</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>小结:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</span><br><span class="line">2. 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="key">key</h3>
<p>key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以 更准确、更快速</p>
<p><strong>准确:</strong><br>
如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来，会产生一系列的bug</p>
<p><strong>快速:</strong><br>
key的唯一性可以被Map数据结构充分利用</p>
<h3 id="组件中的data为什么是函数">组件中的data为什么是函数？</h3>
<p>为什么组件中的data必须是一个函数，然后return一个对象，而new Vue实例里，data可以直接是一个对象？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// data</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">	message: &quot;子组件&quot;,</span><br><span class="line">	childName:this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// new Vue</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123;App&#125;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>因为组件是用来复用的，JS里对象是引用关系，这样作用域没有隔离，而new Vue的实例，是不会被复用的，因此不存在引用对象问题</p>
<h3 id="class-与-style-如何动态绑定">Class 与 Style 如何动态绑定？</h3>
<blockquote>
<p>Class 可以通过对象语法和数组语法进行动态绑定：</p>
</blockquote>
<p><strong>对象语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>数组语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &apos;active&apos;,</span><br><span class="line">  errorClass: &apos;text-danger&apos;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Style 也可以通过对象语法和数组语法进行动态绑定：</p>
</blockquote>
<p><strong>对象语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &apos;red&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>数组语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">     color: &apos;red&apos;</span><br><span class="line">   &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">     fontSize:&apos;23px&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="vue的单项数据流">vue的单项数据流</h3>
<p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改</p>
<p>有两种常见的试图改变一个 prop 的情形 :</p>
<p>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用</p>
<blockquote>
<p>在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;initialCounter&apos;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: this.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这个 prop 以一种原始的值传入且需要进行转换</p>
<blockquote>
<p>在这种情况下，最好使用这个 prop 的值来定义一个计算属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;size&apos;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="keep-alive">keep-alive</h3>
<p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h3 id="v-model-的原理">v-model 的原理</h3>
<p>vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件;</li>
</ul>
<p>以 input 表单元素为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&apos;something&apos;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;</span><br><span class="line"></span><br><span class="line">子组件：</span><br><span class="line">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">    value: String</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  test1()&#123;</span><br><span class="line">     this.$emit(&apos;input&apos;, &apos;小红&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="nexttick">nextTick()</h3>
<p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后，立即使用的这个回调函数，获取更新后的DOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 修改数据</span><br><span class="line">vm.msg = &apos;Hello&apos;</span><br><span class="line">// DOM 还未更新</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  // DOM 更新</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="vue插槽">vue插槽</h3>
<p>个人觉得这篇文章写的还可以：<a href="https://www.cnblogs.com/chinabin1993/p/9115396.html" target="_blank" rel="noopener">www.cnblogs.com/chinabin199…</a></p>
<p><strong>单个插槽</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当子组件模板只有一个没有属性的插槽时，</span><br><span class="line">父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，</span><br><span class="line">并替换掉插槽标签本身</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>命名插槽</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solt元素可以用一个特殊的特性name来进一步配置如何分发内容。</span><br><span class="line">多个插槽可以有不同的名字。 这样可以将父组件模板中 slot 位置，</span><br><span class="line">和子组件 slot 元素产生关联，便于插槽内容对应传递</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>作用域插槽</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以访问组件内部数据的可复用插槽(reusable slot)</span><br><span class="line">在父级中，具有特殊特性 slot-scope 的&lt;template&gt; 元素必须存在，</span><br><span class="line">表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，</span><br><span class="line">此变量接收从子组件传递过来的 prop 对象</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="vue-router有哪几种导航钩子">vue-router有哪几种导航钩子</h3>
<p>第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截</p>
<p>第二种：组件内的钩子</p>
<p>第三种：单独路由独享组件</p>
<h3 id="vuex">vuex</h3>
<p><strong>vuex是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data</span><br><span class="line"></span><br><span class="line">state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</span><br><span class="line"></span><br><span class="line">它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p>
<p><strong>state</strong><br>
Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p>
<p><strong>mutations</strong><br>
mutations定义的方法动态修改Vuex 的 store 中的状态或数据</p>
<p><strong>getters</strong><br>
类似vue的计算属性，主要用来过滤一些数据</p>
<p><strong>action</strong><br>
actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action</p>
<p><strong>总结</strong><br>
vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据</p>
<h3 id="你有对-vue-项目进行哪些优化">你有对 Vue 项目进行哪些优化？</h3>
<p><strong>代码层面的优化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v-if 和 v-show 区分使用场景</span><br><span class="line">computed 和 watch  区分使用场景</span><br><span class="line">v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</span><br><span class="line">长列表性能优化</span><br><span class="line">事件的销毁</span><br><span class="line">图片资源懒加载</span><br><span class="line">路由懒加载</span><br><span class="line">第三方插件的按需引入</span><br><span class="line">优化无限列表性能</span><br><span class="line">服务端渲染 SSR or 预渲染</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>Webpack 层面的优化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Webpack 对图片进行压缩</span><br><span class="line">减少 ES6 转为 ES5 的冗余代码</span><br><span class="line">提取公共代码</span><br><span class="line">模板预编译</span><br><span class="line">提取组件的 CSS</span><br><span class="line">优化 SourceMap</span><br><span class="line">构建结果输出分析</span><br><span class="line">Vue 项目的编译优化</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>基础的 Web 技术的优化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启 gzip 压缩</span><br><span class="line">浏览器缓存</span><br><span class="line">CDN 的使用</span><br><span class="line">使用 Chrome Performance 查找性能瓶颈</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="es6">ES6</h2>
<h3 id="var-let-const之间的区别">var、let、const之间的区别</h3>
<p>var声明变量可以重复声明，而let不可以重复声明var是不受限于块级的，而let是受限于块级var会与window相映射（会挂一个属性），而let不与window相映射var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错const声明之后必须赋值，否则会报错const定义不可变的量，改变了就会报错</p>
<p>const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错</p>
<h3 id="解构赋值">解构赋值</h3>
<p><strong>数组解构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3]   //a=1, b=2, c=3</span><br><span class="line">let [d, [e], f] = [1, [2], 3]    //嵌套数组解构 d=1, e=2, f=3</span><br><span class="line">let [g, ...h] = [1, 2, 3]   //数组拆分 g=1, h=[2, 3]</span><br><span class="line">let [i,,j] = [1, 2, 3]   //不连续解构 i=1, j=3</span><br><span class="line">let [k,l] = [1, 2, 3]   //不完全解构 k=1, l=2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>对象解构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let &#123;a, b&#125; = &#123;a: &apos;aaaa&apos;, b: &apos;bbbb&apos;&#125;      //a=&apos;aaaa&apos; b=&apos;bbbb&apos;</span><br><span class="line">let obj = &#123;d: &apos;aaaa&apos;, e: &#123;f: &apos;bbbb&apos;&#125;&#125;</span><br><span class="line">let &#123;d, e:&#123;f&#125;&#125; = obj    //嵌套解构 d=&apos;aaaa&apos; f=&apos;bbbb&apos;</span><br><span class="line">let g;</span><br><span class="line">(g = &#123;g: &apos;aaaa&apos;&#125;)   //以声明变量解构 g=&apos;aaaa&apos;</span><br><span class="line">let [h, i, j, k] = &apos;nice&apos;    //字符串解构 h=&apos;n&apos; i=&apos;i&apos; j=&apos;c&apos; k=&apos;e&apos;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>函数参数的定义</strong></p>
<p>一般我们在定义函数的时候，如果函数有多个参数时，在es5语法中函数调用时参数必须一一对应，否则就会出现赋值错误的情况，来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function personInfo(name, age, address, gender) &#123;</span><br><span class="line">  console.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(&apos;william&apos;, 18, &apos;changsha&apos;, &apos;man&apos;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面这个例子在对用户信息的时候需要传递四个参数，且需要一一对应，这样就会极易出现参数顺序传错的情况，从而导致bug，接下来来看es6解构赋值是怎么解决这个问题的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function personInfo(&#123;name, age, address, gender&#125;) &#123;</span><br><span class="line">  console.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(&#123;gender: &apos;man&apos;, address: &apos;changsha&apos;, name: &apos;william&apos;, age: 18&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这么写我们只知道要传声明参数就行来，不需要知道参数的顺序也没关系</p>
<p><strong>交换变量的值</strong></p>
<p>在es5中我们需要交换两个变量的值需要借助临时变量的帮助，来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a=1, b=2, c</span><br><span class="line">c = a</span><br><span class="line">a = b</span><br><span class="line">b = c</span><br><span class="line">console.log(a, b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>来看es6怎么实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a=1, b=2;</span><br><span class="line">[b, a] = [a, b]</span><br><span class="line">console.log(a, b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>是不是比es5的写法更加方便呢</p>
<p><strong>函数默认参数</strong></p>
<p>在日常开发中，经常会有这种情况：函数的参数需要默认值，如果没有默认值在使用的时候就会报错，来看es5中是怎么做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function saveInfo(name, age, address, gender) &#123;</span><br><span class="line">  name = name || &apos;william&apos;</span><br><span class="line">  age = age || 18</span><br><span class="line">  address = address || &apos;changsha&apos;</span><br><span class="line">  gender = gender || &apos;man&apos;</span><br><span class="line">  console.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在函数离 main先对参数做一个默认值赋值，然后再使用避免使用的过程中报错，再来看es6中的使用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function saveInfo(&#123;name= &apos;william&apos;, age= 18, address= &apos;changsha&apos;, gender= &apos;man&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在函数定义的时候就定义了默认参数，这样就免了后面给参数赋值默认值的过程，是不是看起来简单多了</p>
<h3 id="foreach-for-in-for-of三者区别">forEach、for in、for of三者区别</h3>
<p>forEach更多的用来遍历数for in 一般常用来遍历对象或jsonfor of数组对象都可以遍历，遍历对象需要通过和Object.keys()</p>
<p>for in循环出的是key，for of循环出的是value</p>
<h3 id="使用箭头函数应注意什么">使用箭头函数应注意什么？</h3>
<p>1、用了箭头函数，this就不是指向window，而是父级（指向是可变的）<br>
2、不能够使用arguments对象<br>
3、不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误<br>
4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数</p>
<h3 id="set-map的区别">Set、Map的区别</h3>
<p>应用场景Set用于数据重组，Map用于数据储存</p>
<p><strong>Set：</strong><br>
1，成员不能重复<br>
2，只有键值没有键名，类似数组<br>
3，可以遍历，方法有add, delete,has</p>
<p><strong>Map:</strong><br>
1，本质上是健值对的集合，类似集合<br>
2，可以遍历，可以跟各种数据格式转换</p>
<h3 id="promise对象的用法手写一个promise">promise对象的用法,手写一个promise</h3>
<p>promise是一个构造函数，下面是一个简单实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    // success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    // failure</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="ajax">Ajax</h2>
<h3 id="如何创建一个ajax">如何创建一个ajax</h3>
<p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象<br>
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br>
(3)设置响应HTTP请求状态变化的函数<br>
(4)发送HTTP请求<br>
(5)获取异步调用返回的数据<br>
(6)使用JavaScript和DOM实现局部刷新</p>
<h3 id="同步和异步的区别">同步和异步的区别</h3>
<p><strong>同步：</strong><br>
浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</p>
<p><strong>异步：</strong><br>
浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</p>
<h3 id="ajax的优点和缺点">ajax的优点和缺点</h3>
<p><strong>ajax的优点</strong></p>
<p>1、无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）<br>
2、异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）<br>
3、前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）<br>
4、界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）</p>
<p><strong>ajax的缺点</strong></p>
<p>1、ajax不支持浏览器back按钮<br>
2、安全问题 Aajax暴露了与服务器交互的细节<br>
3、对搜索引擎的支持比较弱<br>
4、破坏了Back与History后退按钮的正常行为等浏览器机制</p>
<h3 id="get和post的区别">get和post的区别</h3>
<p>1、get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些 2、get相对post安全性低<br>
3、get有缓存，post没有<br>
4、get体积小，post可以无限大<br>
5、get的url参数可见，post不可见<br>
6、get只接受ASCII字符的参数数据类型，post没有限制<br>
7、get请求参数会保留历史记录，post中参数不会保留<br>
8、get会被浏览器主动catch，post不会，需要手动设置<br>
9、get在浏览器回退时无害，post会再次提交请求</p>
<p><strong>什么时候使用post？</strong></p>
<p>post一般用于修改服务器上的资源，对所发送的信息没有限制。比如</p>
<p>1、无法使用缓存文件（更新服务器上的文件或数据库）<br>
2、向服务器发送大量数据（POST 没有数据量限制）<br>
3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<h3 id="如何解决跨域问题">如何解决跨域问题</h3>
<p>跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p>
<p><strong>解决跨域问题：</strong></p>
<p>1、使用JSONP（json+padding）把数据内填充起来<br>
2、CORS方式（跨域资源共享），在后端上配置可跨域<br>
3、服务器代理，通过服务器的文件能访问第三方资源</p>
<h3 id="什么是ajax和json它们的优点和缺点">什么是Ajax和JSON，它们的优点和缺点</h3>
<p><strong>Ajax：</strong></p>
<p>Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互</p>
<p><strong>Ajax优点：</strong></p>
<p>异步请求响应快，用户体验好；页面无刷新、数据局部更新；按需取数据，减少了冗余请求和服务器的负担；</p>
<p><strong>Ajax缺点：</strong></p>
<p>异步回调问题、this指向问题、路由跳转back问题；对搜索引擎的支持比较弱，对于一些手机还不是很好的支持</p>
<p><strong>JSON：</strong></p>
<p>是一种轻量级的数据交换格式，看着像对象，本质是字符串</p>
<p><strong>JSON优点：</strong></p>
<p>轻量级、易于人的阅读和编写，便于js解析，支持复合数据类型</p>
<p><strong>JSON缺点：</strong></p>
<p>没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性</p>
<h2 id="github">Github</h2>
<h3 id="git常用的命令">git常用的命令</h3>
<p>从远程库克隆到本地：git clone 网站上的仓库地址新增文件的命令：git add .提交文件的命令：git commit –m或者git commit –a查看工作区状况：git status –s拉取合并远程分支的操作：git fetch/git merge或者git pull</p>
<p>查看提交记录命令：git reflog</p>
<h2 id="webpack">webpack</h2>
<h3 id="webpack打包原理">webpack打包原理</h3>
<p>webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。webpack做的就是分析代码。转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)</p>
<h3 id="模块热更新">模块热更新</h3>
<p>模块热更新是webpack的一个功能，他可以使代码修改过后不用刷新就可以更新，是高级版的自动刷新浏览器</p>
<blockquote>
<p>devServer中通过hot属性可以控制模块的热替换</p>
</blockquote>
<p><strong>通过配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">let env = process.env.NODE_ENV == &quot;development&quot; ? &quot;development&quot; : &quot;production&quot;;</span><br><span class="line">const config = &#123;</span><br><span class="line">  mode: env,</span><br><span class="line"> devServer: &#123;</span><br><span class="line">     hot:true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  plugins: [</span><br><span class="line">     new webpack.HotModuleReplacementPlugin(), //热加载插件</span><br><span class="line">  ],</span><br><span class="line">module.exports = config;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>通过命令行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;NODE_ENV=development  webpack-dev-server --config  webpack.develop.config.js --hot&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="如何提高webpack构建速度">如何提高webpack构建速度</h3>
<p>1、通过externals配置来提取常用库</p>
<p>2、利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来</p>
<p>3、使用Happypack 实现多线程加速编译</p>
<p>要注意的第一点是，它对file-loader和url-loader支持不好，所以这两个loader就不需要换成happypack了，其他loader可以类似地换一下</p>
<p>4、使用Tree-shaking和Scope Hoisting来剔除多余代码 5、使用fast-sass-loader代替sass-loader 6、babel-loader开启缓存</p>
<p>babel-loader在执行的时候，可能会产生一些运行期间重复的公共文件，造成代码体积大冗余，同时也会减慢编译效率 可以加上cacheDirectory参数或使用 transform-runtime 插件试试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">use: [&#123;</span><br><span class="line">    loader: &apos;babel-loader&apos;,</span><br><span class="line">    options: &#123;</span><br><span class="line">        cacheDirectory: true</span><br><span class="line">&#125;]</span><br><span class="line">// .bablerc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        &quot;react&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>不需要打包编译的插件库换成全局&quot;script&quot;标签引入的方式</p>
<p>比如jQuery插件，react, react-dom等，代码量是很多的，打包起来可能会很耗时 可以直接用标签引入，然后在webpack配置里使用 expose-loader 或 externals 或 ProvidePlugin 提供给模块内部使用相应的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// @1</span><br><span class="line">use: [&#123;</span><br><span class="line">    loader: &apos;expose-loader&apos;,</span><br><span class="line">    options: &apos;$&apos;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">    loader: &apos;expose-loader&apos;,</span><br><span class="line">    options: &apos;jQuery&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">// @2</span><br><span class="line">externals: &#123;</span><br><span class="line">        jquery: &apos;jQuery&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">// @3</span><br><span class="line">        new webpack.ProvidePlugin(&#123;</span><br><span class="line">            $: &apos;jquery&apos;,</span><br><span class="line">            jQuery: &apos;jquery&apos;,</span><br><span class="line">            &apos;window.jQuery&apos;: &apos;jquery&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>8、优化构建时的搜索路径</p>
<p>在webpack打包时，会有各种各样的路径要去查询搜索，我们可以加上一些配置，让它搜索地更快 比如说，方便改成绝对路径的模块路径就改一下，以纯模块名来引入的可以加上一些目录路径 还可以善于用下resolve alias别名 这个字段来配置 还有exclude等的配置，避免多余查找的文件，比如使用babel别忘了剔除不需要遍历的</p>
<h3 id="webpack的优点">webpack的优点</h3>
<p>专注于处理模块化的项目，能做到开箱即用，一步到位可通过plugin扩展，完整好用又不失灵活使用场景不局限于web开发社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展</p>
<p>良好的开发体验</p>
<h3 id="webpack的缺点">webpack的缺点</h3>
<p>webpack的缺点是只能用于采用模块化开发的项目</p>
<h2 id="微信小程序">微信小程序</h2>
<h3 id="文件主要目录及文件作用">文件主要目录及文件作用</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- component —————————————————— 组件文件夹</span><br><span class="line">  - navBar                  —— 底部组件</span><br><span class="line">    - navBar.js             —— 底部组件的 JS 代码</span><br><span class="line">    - navBar.json           —— 底部组件的配置文件</span><br><span class="line">    - navBar.wxml           —— 底部组件的 HTML 代码</span><br><span class="line">    - navBar.wxss           —— 底部组件的 CSS 代码</span><br><span class="line">- pages  ————————————————————— 页面文件夹</span><br><span class="line">  - index                   —— 首页</span><br><span class="line">    - index.js              —— 首页的 JS 代码</span><br><span class="line">    - index.json            —— 首页的配置文件</span><br><span class="line">    - index.wxml            —— 首页的 HTML 代码</span><br><span class="line">    - index.wxss            —— 首页的 CSS 代码</span><br><span class="line">- public ————————————————————— 图片文件夹</span><br><span class="line">- utils —————————————————————— 工具文件夹</span><br><span class="line">  - api.js                  —— 控制 API 的文件</span><br><span class="line">  - md5.js                  —— 工具 - MD5 加密文件</span><br><span class="line">  - timestamp.js            —— 工具 - 时间戳文件</span><br><span class="line">- app.json ——————————————————— 设置全局的基础数据等</span><br><span class="line">- app.wxss ——————————————————— 公共样式，可通过 import 导入更多</span><br><span class="line">- project.config.json ———————— 项目配置文件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="微信小程序生命周期">微信小程序生命周期</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onLoad()：页面加载时触发。</span><br><span class="line">onShow()：页面显示/切入前台时触发。</span><br><span class="line">onReady()：页面初次渲染完成时触发。</span><br><span class="line">onHide()：页面隐藏/切入后台时触发。</span><br><span class="line">onUnload()：页面卸载时触发。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="如何封装数据请求">如何封装数据请求</h3>
<p><strong>1，封装接口</strong></p>
<blockquote>
<p>项目/utils/api.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 将请求进行 Promise 封装</span><br><span class="line">const fetch = (&#123;url, data&#125;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 打印接口请求的信息</span><br><span class="line">  console.log(`【step 1】API 接口：$&#123;url&#125;`);</span><br><span class="line">  console.log(&quot;【step 2】data 传参：&quot;);</span><br><span class="line">  console.log(data);</span><br><span class="line"></span><br><span class="line">  // 返回 Promise</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: getApp().globalData.api + url,</span><br><span class="line">      data: data,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        // 成功时的处理 </span><br><span class="line">        if (res.data.code == 0) &#123;</span><br><span class="line">          console.log(&quot;【step 3】请求成功：&quot;);</span><br><span class="line">          console.log(res.data);</span><br><span class="line">          return resolve(res.data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          wx.showModal(&#123;</span><br><span class="line">            title: &apos;请求失败&apos;,</span><br><span class="line">            content: res.data.message,</span><br><span class="line">            showCancel: false</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">      fail: err =&gt; &#123;</span><br><span class="line">        // 失败时的处理</span><br><span class="line">        console.log(err);</span><br><span class="line">        return reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * code 换取 openId</span><br><span class="line"> * @data &#123;</span><br><span class="line"> *   jsCode - wx.login() 返回的 code</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">export const wxLogin = data =&gt; &#123;</span><br><span class="line">  return fetch(&#123;</span><br><span class="line">    url: &quot;tbcUser/getWechatOpenId&quot;,</span><br><span class="line">    data: data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>2，调用接口</strong></p>
<blockquote>
<p>项目/pages/login/login.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  wxLogin,</span><br><span class="line">&#125; from &apos;../../utils/api.js&apos;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>3，使用接口</strong></p>
<blockquote>
<p>项目/pages/login/login.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wxLogin(&#123;</span><br><span class="line">  jsCode: this.data.code</span><br><span class="line">&#125;).then(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    console.log(&quot;【step 4】返回成功处理：&quot;);</span><br><span class="line">    console.log(res.data);</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    console.log(&quot;【step 4】返回失败处理：&quot;);</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="页面数据传递">页面数据传递</h3>
<p>通过 url 携带参数，在 onLoad() 中通过 options 获取 url 上的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigator url=&quot;../index/index?userId=&#123;&#123;userId&#125;&#125;&quot;&gt;&lt;/navigator&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 这两段是分别在 HTML 和 JS 中的代码 --&gt;</span><br><span class="line"></span><br><span class="line">onLoad: function(options) &#123;</span><br><span class="line">  console.log(options.userId);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>通过 Storage 来传递参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.setStorageSync(&apos;userId&apos;, &apos;jsliang&apos;);</span><br><span class="line">wx.getStorageSync(&apos;userId&apos;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>WXML传递数据到 JS</p>
<blockquote>
<p>login.wxml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;text bindtap=&quot;clickText&quot; data-labelId=&quot;&#123;&#123;userId&#125;&#125;&quot;&gt;点击传递数据到 JS&lt;/text&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>login.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clickText(e) &#123;</span><br><span class="line">  console.log(e.currentTarget.labelid)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>组件调用传参</p>
<blockquote>
<p>组件接收数据：component-tag-name</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    // 这里定义了innerText属性，属性值可以在组件使用时指定</span><br><span class="line">    innerText: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      value: &apos;default value&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用组件的页面定义 json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;component-tag-name&quot;: &quot;../component/component&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用组件的页面 HTML 代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;!-- 以下是对一个自定义组件的引用 --&gt;</span><br><span class="line">  &lt;component-tag-name inner-text=&quot;Some text&quot;&gt;&lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>通过接口调用传递参数</p>
<h3 id="加载性能优化方法">加载性能优化方法</h3>
<p>1、通过 this.$preload() 预加载用户可能点击的第二个页面2、组件化页面，出现两次以上的部分都进行封装成组件3、提取共用的 CSS 样式</p>
<p>4、优化图片：TinyPNG</p>
<h3 id="微信小程序与原生app-vue-h5差异">微信小程序与原生APP、Vue、H5差异</h3>
<p><strong>微信小程序优势</strong></p>
<p>1、无需下载<br>
2、打开速度较快<br>
3、开发成本低于原生APP</p>
<p><strong>微信小程序劣势</strong></p>
<p>1、限制多。页面大小不能超过 1M，不能打开超过 5 个层级的页面<br>
2、样式单一。小程序内部组件已经成宿，样式不可以修改<br>
3、推广面窄。跑不出微信，还不能跑入朋友圈</p>
<p><strong>微信小程序 VS 原生APP</strong><br>
微信小程序有着低开发成本、低获客成本、无需下载的优势</p>
<p><strong>微信小程序 VS H5</strong><br>
1、依赖环境不同。一个能在多种手机浏览器运行。一个只能在微信中的非完整的浏览器<br>
2、开发成本不同。一个可能在各种浏览器出问题。一个只能在微信中运行</p>
<p><strong>微信小程序 VS Vue</strong><br>
微信小程序看似就是阉割版的 Vue</p>
<h3 id="微信小程序原理">微信小程序原理</h3>
<p>本质上就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面中进行</p>
<p>架构为数据驱动的模式，UI 和数据分离，所有页面的更新，都需要通过对数据的更改来实现</p>
<p>微信小程序分为两个部分：webview 和 appService。其中 webview 主要用来展示 UI，appServer 用来处理业务逻辑、数据及接口调用。它们在两个进程中进行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理</p>
<h3 id="wxml与标准的html的异同">wxml与标准的html的异同</h3>
<p>wxml基于xml设计，标签只能在微信小程序中使用，不能使用html的标签</p>
<h2 id="网络协议">网络协议</h2>
<h3 id="网络分层">网络分层</h3>
<p>目前网络分层可分为两种：OSI 模型和 TCP/IP 模型</p>
<p><strong>OSI模型</strong><br>
应用层（Application）<br>
表示层（Presentation）<br>
会话层（Session）<br>
传输层（Transport）<br>
网络层（Network）<br>
数据链路层（Data Link）<br>
物理层（Physical）</p>
<p><strong>TCP/IP模型</strong><br>
应用层（Application）<br>
传输层（Host-to-Host Transport）<br>
互联网层（Internet）<br>
网络接口层（Network Interface）</p>
<h3 id="httphttps">HTTP/HTTPS</h3>
<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用<br>
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议<br>
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443<br>
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<h3 id="http状态码">HTTP状态码</h3>
<p><strong>区分状态码</strong><br>
1××开头 - 信息提示<br>
2××开头 - 请求成功<br>
3××开头 - 请求被重定向<br>
4××开头 - 请求错误<br>
5××开头 - 服务器错误</p>
<p><strong>常见状态码</strong><br>
200 - 请求成功，Ajax 接受到信息了<br>
400 - 服务器不理解请求<br>
403 - 服务器拒绝请求<br>
404 - 请求页面错误<br>
500 - 服务器内部错误，无法完成请求</p>
<h2 id="性能优化">性能优化</h2>
<h3 id="html优化">HTML优化</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、避免 HTML 中书写 CSS 代码，因为这样难以维护。</span><br><span class="line">2、使用 Viewport 加速页面的渲染。</span><br><span class="line">3、使用语义化标签，减少 CSS 代码，增加可读性和 SEO。</span><br><span class="line">4、减少标签的使用，DOM 解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。</span><br><span class="line">5、避免 src、href 等的值为空，因为即时它们为空，浏览器也会发起 HTTP 请求。</span><br><span class="line">6、减少 DNS 查询的次数</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="css优化">CSS优化</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、优化选择器路径：使用 .c &#123;&#125; 而不是 .a .b .c &#123;&#125;。</span><br><span class="line">2、选择器合并：共同的属性内容提起出来，压缩空间和资源开销。</span><br><span class="line">3、精准样式：使用 padding-left: 10px 而不是 padding: 0 0 0 10px。</span><br><span class="line">4、雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。</span><br><span class="line">5、避免通配符：.a .b * &#123;&#125; 这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符 * &#123;&#125; 6、会遍历整个 DOM，性能大大损耗。</span><br><span class="line">7、少用 float：float 在渲染时计算量比较大，可以使用 flex 布局。</span><br><span class="line">8、为 0 值去单位：增加兼容性。</span><br><span class="line">9、压缩文件大小，减少资源下载负担。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="javascript优化">JavaScript优化</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、尽可能把 &lt;script&gt; 标签放在 body 之后，避免 JS 的执行卡住 DOM 的渲染，最大程度保证页面尽快地展示出来</span><br><span class="line">2、尽可能合并 JS 代码：提取公共方法，进行面向对象设计等……</span><br><span class="line">3、CSS 能做的事情，尽量不用 JS 来做，毕竟 JS 的解析执行比较粗暴，而 CSS 效率更高。</span><br><span class="line">4、尽可能逐条操作 DOM，并预定好 CSs 样式，从而减少 reflow 或者 repaint 的次数。</span><br><span class="line">5、尽可能少地创建 DOM，而是在 HTML 和 CSS 中使用 display: none 来隐藏，按需显示。</span><br><span class="line">6、压缩文件大小，减少资源下载负担。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="面试常见的其他问题">面试常见的其他问题</h2>
<h3 id="常问">常问</h3>
<p>1、自我介绍<br>
2、你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？<br>
3、你认为哪个项目做得最好？<br>
4、平时是如何学习前端开发的？<br>
5、你最有成就感的一件事<br>
6、你是怎么学习前端的</p>
<h3 id="人事面">人事面</h3>
<p>1、面试完你还有什么问题要问的吗<br>
2、你有什么爱好?<br>
3、你最大的优点和缺点是什么?<br>
4、你为什么会选择这个行业，职位?<br>
5、你觉得你适合从事这个岗位吗?<br>
6、你有什么职业规划?<br>
7、你对工资有什么要求?<br>
8、如何看待前端开发？<br>
9、未来三到五年的规划是怎样的？</p>
<h3 id="其他">其他</h3>
<p><strong>谈谈你对重构的理解？</strong></p>
<p>网络重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI</p>
<p>对于传统的网站来说重构通常是：</p>
<ul>
<li>表格(table)布局改为DIV+CSS</li>
<li>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</li>
<li>对于移动平台的优化</li>
<li>针对于SEO进行优化</li>
</ul>
<p><strong>什么样的前端代码是好的？</strong></p>
<p>高复用低耦合，这样文件小，好维护，而且好扩展</p>
<p><strong>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</strong></p>
<p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近</p>
<ul>
<li>实现界面交互</li>
<li>提升用户体验</li>
<li>有了Node.js，前端可以实现服务端的一些事情</li>
</ul>
<p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</p>
<p>与团队成员，UI设计，产品经理的沟通；</p>
<p>做好的页面结构，页面重构和用户体验；</p>
<p><strong>你觉得前端工程的价值体现在哪？</strong></p>
<p>1、为简化用户使用提供技术支持（交互部分）<br>
2、为多个浏览器兼容性提供支持<br>
3、为提高用户浏览速度（浏览器性能）提供支持<br>
4、为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持<br>
5、为展示数据提供支持（数据接口）</p>
<p><strong>平时如何管理你的项目？</strong></p>
<ul>
<li>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</li>
<li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li>
<li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li>
<li>页面进行标注（例如 页面 模块 开始和结束）；</li>
<li>CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</li>
<li>JS 分文件夹存放 命名以该JS功能为准的英文翻译。</li>
<li>图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理</li>
</ul>
<p><strong>移动端（Android IOS）怎么做好用户体验?</strong></p>
<p>清晰的视觉纵线、<br>
信息的分组、极致的减法、<br>
利用选择代替输入、<br>
标签及文字的排布方式、<br>
依靠明文确认密码、<br>
合理的键盘利用</p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/article/正则表达式/" data-toggle="tooltip" data-placement="top" title="正则表达式简单使用">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>
                      
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#前端入坑必须知道的面试题"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">&#x524D;&#x7AEF;&#x5165;&#x5751;&#x5FC5;&#x987B;&#x77E5;&#x9053;&#x7684;&#x9762;&#x8BD5;&#x9898;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#前言"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">&#x524D;&#x8A00;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#html"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">HTML</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#html语义化"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">HTML&#x8BED;&#x4E49;&#x5316;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#html5新标签"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">HTML5&#x65B0;&#x6807;&#x7B7E;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#css"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">CSS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#盒子模型"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text">&#x76D2;&#x5B50;&#x6A21;&#x578B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#rem与em的区别"><span class="toc-nav-number">1.3.2.</span> <span class="toc-nav-text">rem&#x4E0E;em&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#css选择器"><span class="toc-nav-number">1.3.3.</span> <span class="toc-nav-text">CSS&#x9009;&#x62E9;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#css新特性"><span class="toc-nav-number">1.3.4.</span> <span class="toc-nav-text">CSS&#x65B0;&#x7279;&#x6027;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#行内元素和块级元素"><span class="toc-nav-number">1.3.5.</span> <span class="toc-nav-text">&#x884C;&#x5185;&#x5143;&#x7D20;&#x548C;&#x5757;&#x7EA7;&#x5143;&#x7D20;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#绝对定位和相对定位的区别"><span class="toc-nav-number">1.3.6.</span> <span class="toc-nav-text">&#x7EDD;&#x5BF9;&#x5B9A;&#x4F4D;&#x548C;&#x76F8;&#x5BF9;&#x5B9A;&#x4F4D;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#flex布局"><span class="toc-nav-number">1.3.7.</span> <span class="toc-nav-text">Flex&#x5E03;&#x5C40;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#bfc"><span class="toc-nav-number">1.3.8.</span> <span class="toc-nav-text">BFC</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#水平垂直居中"><span class="toc-nav-number">1.3.9.</span> <span class="toc-nav-text">&#x6C34;&#x5E73;&#x5782;&#x76F4;&#x5C45;&#x4E2D;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#lesssassstyus三者的区别"><span class="toc-nav-number">1.3.10.</span> <span class="toc-nav-text">less,sass,styus&#x4E09;&#x8005;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#link与import区别与选择"><span class="toc-nav-number">1.3.11.</span> <span class="toc-nav-text">link&#x4E0E;@import&#x533A;&#x522B;&#x4E0E;&#x9009;&#x62E9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#多行元素的文本省略号"><span class="toc-nav-number">1.3.12.</span> <span class="toc-nav-text">&#x591A;&#x884C;&#x5143;&#x7D20;&#x7684;&#x6587;&#x672C;&#x7701;&#x7565;&#x53F7;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#javascript"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">JavaScript</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#js的几条基本规范"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text">JS&#x7684;&#x51E0;&#x6761;&#x57FA;&#x672C;&#x89C4;&#x8303;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#js引用方法"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text">JS&#x5F15;&#x7528;&#x65B9;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#js的基本数据类型"><span class="toc-nav-number">1.4.3.</span> <span class="toc-nav-text">JS&#x7684;&#x57FA;&#x672C;&#x6570;&#x636E;&#x7C7B;&#x578B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#数组操作"><span class="toc-nav-number">1.4.4.</span> <span class="toc-nav-text">&#x6570;&#x7EC4;&#x64CD;&#x4F5C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#js有哪些内置对象"><span class="toc-nav-number">1.4.5.</span> <span class="toc-nav-text">JS&#x6709;&#x54EA;&#x4E9B;&#x5185;&#x7F6E;&#x5BF9;&#x8C61;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#get请求传参长度的误区"><span class="toc-nav-number">1.4.6.</span> <span class="toc-nav-text">get&#x8BF7;&#x6C42;&#x4F20;&#x53C2;&#x957F;&#x5EA6;&#x7684;&#x8BEF;&#x533A;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#补充get和post请求在缓存方面的区别"><span class="toc-nav-number">1.4.7.</span> <span class="toc-nav-text">&#x8865;&#x5145;get&#x548C;post&#x8BF7;&#x6C42;&#x5728;&#x7F13;&#x5B58;&#x65B9;&#x9762;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#闭包"><span class="toc-nav-number">1.4.8.</span> <span class="toc-nav-text">&#x95ED;&#x5305;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#js作用域及作用域链"><span class="toc-nav-number">1.4.9.</span> <span class="toc-nav-text">JS&#x4F5C;&#x7528;&#x57DF;&#x53CA;&#x4F5C;&#x7528;&#x57DF;&#x94FE;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#原型和原型链"><span class="toc-nav-number">1.4.10.</span> <span class="toc-nav-text">&#x539F;&#x578B;&#x548C;&#x539F;&#x578B;&#x94FE;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#组件化和模块化"><span class="toc-nav-number">1.4.11.</span> <span class="toc-nav-text">&#x7EC4;&#x4EF6;&#x5316;&#x548C;&#x6A21;&#x5757;&#x5316;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#图片的预加载和懒加载"><span class="toc-nav-number">1.4.12.</span> <span class="toc-nav-text">&#x56FE;&#x7247;&#x7684;&#x9884;&#x52A0;&#x8F7D;&#x548C;&#x61D2;&#x52A0;&#x8F7D;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#mouseover和mouseenter的区别"><span class="toc-nav-number">1.4.13.</span> <span class="toc-nav-text">mouseover&#x548C;mouseenter&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#解决异步回调地狱"><span class="toc-nav-number">1.4.14.</span> <span class="toc-nav-text">&#x89E3;&#x51B3;&#x5F02;&#x6B65;&#x56DE;&#x8C03;&#x5730;&#x72F1;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#对this对象的理解"><span class="toc-nav-number">1.4.15.</span> <span class="toc-nav-text">&#x5BF9;This&#x5BF9;&#x8C61;&#x7684;&#x7406;&#x89E3;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#vue"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">Vue</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vue生命周期"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">vue&#x751F;&#x547D;&#x5468;&#x671F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#v-show与v-if区别"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text">v-show&#x4E0E;v-if&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#开发中常用的指令有哪些"><span class="toc-nav-number">1.5.3.</span> <span class="toc-nav-text">&#x5F00;&#x53D1;&#x4E2D;&#x5E38;&#x7528;&#x7684;&#x6307;&#x4EE4;&#x6709;&#x54EA;&#x4E9B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#绑定class的数组用法"><span class="toc-nav-number">1.5.4.</span> <span class="toc-nav-text">&#x7ED1;&#x5B9A;class&#x7684;&#x6570;&#x7EC4;&#x7528;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#组件之间的传值通信"><span class="toc-nav-number">1.5.5.</span> <span class="toc-nav-text">&#x7EC4;&#x4EF6;&#x4E4B;&#x95F4;&#x7684;&#x4F20;&#x503C;&#x901A;&#x4FE1;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#路由跳转方式"><span class="toc-nav-number">1.5.6.</span> <span class="toc-nav-text">&#x8DEF;&#x7531;&#x8DF3;&#x8F6C;&#x65B9;&#x5F0F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#mvvm"><span class="toc-nav-number">1.5.7.</span> <span class="toc-nav-text">MVVM</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#computed和watch有什么区别"><span class="toc-nav-number">1.5.8.</span> <span class="toc-nav-text">computed&#x548C;watch&#x6709;&#x4EC0;&#x4E48;&#x533A;&#x522B;?</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#key"><span class="toc-nav-number">1.5.9.</span> <span class="toc-nav-text">key</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#组件中的data为什么是函数"><span class="toc-nav-number">1.5.10.</span> <span class="toc-nav-text">&#x7EC4;&#x4EF6;&#x4E2D;&#x7684;data&#x4E3A;&#x4EC0;&#x4E48;&#x662F;&#x51FD;&#x6570;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#class-与-style-如何动态绑定"><span class="toc-nav-number">1.5.11.</span> <span class="toc-nav-text">Class &#x4E0E; Style &#x5982;&#x4F55;&#x52A8;&#x6001;&#x7ED1;&#x5B9A;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vue的单项数据流"><span class="toc-nav-number">1.5.12.</span> <span class="toc-nav-text">vue&#x7684;&#x5355;&#x9879;&#x6570;&#x636E;&#x6D41;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#keep-alive"><span class="toc-nav-number">1.5.13.</span> <span class="toc-nav-text">keep-alive</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#v-model-的原理"><span class="toc-nav-number">1.5.14.</span> <span class="toc-nav-text">v-model &#x7684;&#x539F;&#x7406;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#nexttick"><span class="toc-nav-number">1.5.15.</span> <span class="toc-nav-text">nextTick()</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vue插槽"><span class="toc-nav-number">1.5.16.</span> <span class="toc-nav-text">vue&#x63D2;&#x69FD;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vue-router有哪几种导航钩子"><span class="toc-nav-number">1.5.17.</span> <span class="toc-nav-text">vue-router&#x6709;&#x54EA;&#x51E0;&#x79CD;&#x5BFC;&#x822A;&#x94A9;&#x5B50;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vuex"><span class="toc-nav-number">1.5.18.</span> <span class="toc-nav-text">vuex</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#你有对-vue-项目进行哪些优化"><span class="toc-nav-number">1.5.19.</span> <span class="toc-nav-text">&#x4F60;&#x6709;&#x5BF9; Vue &#x9879;&#x76EE;&#x8FDB;&#x884C;&#x54EA;&#x4E9B;&#x4F18;&#x5316;&#xFF1F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#es6"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text">ES6</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#var-let-const之间的区别"><span class="toc-nav-number">1.6.1.</span> <span class="toc-nav-text">var&#x3001;let&#x3001;const&#x4E4B;&#x95F4;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#解构赋值"><span class="toc-nav-number">1.6.2.</span> <span class="toc-nav-text">&#x89E3;&#x6784;&#x8D4B;&#x503C;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#foreach-for-in-for-of三者区别"><span class="toc-nav-number">1.6.3.</span> <span class="toc-nav-text">forEach&#x3001;for in&#x3001;for of&#x4E09;&#x8005;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#使用箭头函数应注意什么"><span class="toc-nav-number">1.6.4.</span> <span class="toc-nav-text">&#x4F7F;&#x7528;&#x7BAD;&#x5934;&#x51FD;&#x6570;&#x5E94;&#x6CE8;&#x610F;&#x4EC0;&#x4E48;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#set-map的区别"><span class="toc-nav-number">1.6.5.</span> <span class="toc-nav-text">Set&#x3001;Map&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#promise对象的用法手写一个promise"><span class="toc-nav-number">1.6.6.</span> <span class="toc-nav-text">promise&#x5BF9;&#x8C61;&#x7684;&#x7528;&#x6CD5;,&#x624B;&#x5199;&#x4E00;&#x4E2A;promise</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ajax"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text">Ajax</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何创建一个ajax"><span class="toc-nav-number">1.7.1.</span> <span class="toc-nav-text">&#x5982;&#x4F55;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;ajax</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#同步和异步的区别"><span class="toc-nav-number">1.7.2.</span> <span class="toc-nav-text">&#x540C;&#x6B65;&#x548C;&#x5F02;&#x6B65;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ajax的优点和缺点"><span class="toc-nav-number">1.7.3.</span> <span class="toc-nav-text">ajax&#x7684;&#x4F18;&#x70B9;&#x548C;&#x7F3A;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#get和post的区别"><span class="toc-nav-number">1.7.4.</span> <span class="toc-nav-text">get&#x548C;post&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何解决跨域问题"><span class="toc-nav-number">1.7.5.</span> <span class="toc-nav-text">&#x5982;&#x4F55;&#x89E3;&#x51B3;&#x8DE8;&#x57DF;&#x95EE;&#x9898;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#什么是ajax和json它们的优点和缺点"><span class="toc-nav-number">1.7.6.</span> <span class="toc-nav-text">&#x4EC0;&#x4E48;&#x662F;Ajax&#x548C;JSON&#xFF0C;&#x5B83;&#x4EEC;&#x7684;&#x4F18;&#x70B9;&#x548C;&#x7F3A;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#github"><span class="toc-nav-number">1.8.</span> <span class="toc-nav-text">Github</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#git常用的命令"><span class="toc-nav-number">1.8.1.</span> <span class="toc-nav-text">git&#x5E38;&#x7528;&#x7684;&#x547D;&#x4EE4;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#webpack"><span class="toc-nav-number">1.9.</span> <span class="toc-nav-text">webpack</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#webpack打包原理"><span class="toc-nav-number">1.9.1.</span> <span class="toc-nav-text">webpack&#x6253;&#x5305;&#x539F;&#x7406;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#模块热更新"><span class="toc-nav-number">1.9.2.</span> <span class="toc-nav-text">&#x6A21;&#x5757;&#x70ED;&#x66F4;&#x65B0;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何提高webpack构建速度"><span class="toc-nav-number">1.9.3.</span> <span class="toc-nav-text">&#x5982;&#x4F55;&#x63D0;&#x9AD8;webpack&#x6784;&#x5EFA;&#x901F;&#x5EA6;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#webpack的优点"><span class="toc-nav-number">1.9.4.</span> <span class="toc-nav-text">webpack&#x7684;&#x4F18;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#webpack的缺点"><span class="toc-nav-number">1.9.5.</span> <span class="toc-nav-text">webpack&#x7684;&#x7F3A;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#微信小程序"><span class="toc-nav-number">1.10.</span> <span class="toc-nav-text">&#x5FAE;&#x4FE1;&#x5C0F;&#x7A0B;&#x5E8F;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#文件主要目录及文件作用"><span class="toc-nav-number">1.10.1.</span> <span class="toc-nav-text">&#x6587;&#x4EF6;&#x4E3B;&#x8981;&#x76EE;&#x5F55;&#x53CA;&#x6587;&#x4EF6;&#x4F5C;&#x7528;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#微信小程序生命周期"><span class="toc-nav-number">1.10.2.</span> <span class="toc-nav-text">&#x5FAE;&#x4FE1;&#x5C0F;&#x7A0B;&#x5E8F;&#x751F;&#x547D;&#x5468;&#x671F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何封装数据请求"><span class="toc-nav-number">1.10.3.</span> <span class="toc-nav-text">&#x5982;&#x4F55;&#x5C01;&#x88C5;&#x6570;&#x636E;&#x8BF7;&#x6C42;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#页面数据传递"><span class="toc-nav-number">1.10.4.</span> <span class="toc-nav-text">&#x9875;&#x9762;&#x6570;&#x636E;&#x4F20;&#x9012;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#加载性能优化方法"><span class="toc-nav-number">1.10.5.</span> <span class="toc-nav-text">&#x52A0;&#x8F7D;&#x6027;&#x80FD;&#x4F18;&#x5316;&#x65B9;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#微信小程序与原生app-vue-h5差异"><span class="toc-nav-number">1.10.6.</span> <span class="toc-nav-text">&#x5FAE;&#x4FE1;&#x5C0F;&#x7A0B;&#x5E8F;&#x4E0E;&#x539F;&#x751F;APP&#x3001;Vue&#x3001;H5&#x5DEE;&#x5F02;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#微信小程序原理"><span class="toc-nav-number">1.10.7.</span> <span class="toc-nav-text">&#x5FAE;&#x4FE1;&#x5C0F;&#x7A0B;&#x5E8F;&#x539F;&#x7406;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#wxml与标准的html的异同"><span class="toc-nav-number">1.10.8.</span> <span class="toc-nav-text">wxml&#x4E0E;&#x6807;&#x51C6;&#x7684;html&#x7684;&#x5F02;&#x540C;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#网络协议"><span class="toc-nav-number">1.11.</span> <span class="toc-nav-text">&#x7F51;&#x7EDC;&#x534F;&#x8BAE;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#网络分层"><span class="toc-nav-number">1.11.1.</span> <span class="toc-nav-text">&#x7F51;&#x7EDC;&#x5206;&#x5C42;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#httphttps"><span class="toc-nav-number">1.11.2.</span> <span class="toc-nav-text">HTTP/HTTPS</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#http状态码"><span class="toc-nav-number">1.11.3.</span> <span class="toc-nav-text">HTTP&#x72B6;&#x6001;&#x7801;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#性能优化"><span class="toc-nav-number">1.12.</span> <span class="toc-nav-text">&#x6027;&#x80FD;&#x4F18;&#x5316;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#html优化"><span class="toc-nav-number">1.12.1.</span> <span class="toc-nav-text">HTML&#x4F18;&#x5316;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#css优化"><span class="toc-nav-number">1.12.2.</span> <span class="toc-nav-text">CSS&#x4F18;&#x5316;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#javascript优化"><span class="toc-nav-number">1.12.3.</span> <span class="toc-nav-text">JavaScript&#x4F18;&#x5316;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#面试常见的其他问题"><span class="toc-nav-number">1.13.</span> <span class="toc-nav-text">&#x9762;&#x8BD5;&#x5E38;&#x89C1;&#x7684;&#x5176;&#x4ED6;&#x95EE;&#x9898;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#常问"><span class="toc-nav-number">1.13.1.</span> <span class="toc-nav-text">&#x5E38;&#x95EE;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#人事面"><span class="toc-nav-number">1.13.2.</span> <span class="toc-nav-text">&#x4EBA;&#x4E8B;&#x9762;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#其他"><span class="toc-nav-number">1.13.3.</span> <span class="toc-nav-text">&#x5176;&#x4ED6;</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://weibo.com/panweibin" target="_blank">Weibo</a></li>
                    
                        <li><a href="https://github.com/RyzenPan" target="_blank">Github</a></li>
                    
                        <li><a href="https://space.bilibili.com/29478020" target="_blank">bilibili</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/RyzenPan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; RyzenPan 2020 
                    <br>
                    View by <a href="javascript:;">VPro</a> 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://ryzenpan.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://ryzenpan.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
